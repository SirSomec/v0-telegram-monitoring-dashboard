# План подключения оплаты

Документ описывает шаги по интеграции платёжного провайдера в сервис мониторинга. Сейчас тариф и срок действия назначаются вручную администратором; цель — дать пользователю возможность оплатить тариф самостоятельно (разовая оплата за период или подписка).

---

## 1. Текущее состояние

- **Модель:** у пользователя есть `plan_slug` (free | basic | pro | business) и `plan_expires_at`. При истечении срока эффективный план = free (`plans.get_effective_plan`).
- **Лимиты:** заданы в `plans.LIMITS` и в таблице `plan_limits`; проверки при добавлении каналов/ключевых слов уже реализованы (`_check_limits`, `_check_plan_can_track` в `main.py`).
- **API:** `GET /api/plan` — текущий тариф, лимиты и использование; админ меняет тариф через `PATCH /api/users/:id` (plan, planExpiresAt).
- **Фронт:** модальное окно «Оплата» (BillingModal) показывает тариф, срок и использование; текст: «Тариф назначает администратор».

**Чего нет:** создания платежа, редиректа на оплату, обработки успешной оплаты (webhook/callback), истории платежей.

---

## 2. Выбор платёжного провайдера

| Вариант | Плюсы | Минусы |
|--------|--------|--------|
| **ЮKassa** | Популярно в РФ, документация, API и виджеты | Нужна регистрация как ИП/ООО |
| **Robokassa** | Простая интеграция, подходит для РФ | |
| **Tinkoff (Acquiring)** | Удобно при расчётном счёте в Тинькофф | |
| **Stripe** | Международные карты, подписки из коробки | Ограничения для РФ |
| **CloudPayments** | РФ, рекуррентные платежи | |

Рекомендация: для российского продукта — **ЮKassa** или **Robokassa**; при необходимости рекуррентных списаний — провайдер с поддержкой подписок (CloudPayments, Stripe для не-РФ).

---

## 3. Сценарии оплаты

### 3.1 Разовая оплата за период (рекомендуется на старте)

- Пользователь выбирает план (basic/pro/business) и период (месяц/3 месяца/год).
- Бэкенд создаёт платёж у провайдера (payment/session), возвращает ссылку на оплату (или id для виджета).
- Пользователь переходит по ссылке, платит; провайдер отправляет webhook «успех» на наш backend.
- Backend по webhook: обновляет у пользователя `plan_slug` и `plan_expires_at` (продлевает от текущей даты или от уже имеющегося срока — решить политику).

### 3.2 Подписка (рекуррент)

- При необходимости автоматического продления — использовать рекуррентные платежи провайдера (сохранение карты, списание по расписанию). Требует больше настроек и отдельной логики отмены/смены плана.

На первом этапе достаточно **разовой оплаты за период**.

---

## 4. Доработки backend

### 4.1 Модель данных

- **Таблица `payments` (или `payment_transactions`):**
  - `id`, `user_id` (FK), `external_id` (id платежа у провайдера), `provider` (yookassa, robokassa, …)
  - `plan_slug` (за какой план платили), `amount`, `currency`, `status` (pending | succeeded | failed | refunded)
  - `period_start`, `period_end` (опционально — какой период оплачен)
  - `created_at`, `updated_at`
  - Назначение: история платежей, идемпотентность webhook (не применять один и тот же `external_id` дважды), отладка.

- Опционально: таблица `products` / `prices` (plan_slug + period → product_id провайдера и сумма). Можно пока зашить в конфиг (см. ниже).

### 4.2 Конфигурация

- В `parser_config` или отдельный конфиг/ env:
  - Ключи доступа к платёжному провайдеру (secret key, shop id и т.д.).
  - Список продуктов: например `PAYMENT_PRODUCT_BASIC_MONTH`, `PAYMENT_PRICE_BASIC_MONTH` (или один JSON с планами и периодами).
- Webhook URL: `https://<ваш-домен>/api/webhooks/payments/<provider>` — должен быть в настройках кабинета провайдера.

### 4.3 API

- **POST /api/payments/create** (или `/api/plan/checkout`):
  - Body: `{ "planSlug": "basic" | "pro" | "business", "period": "month" | "quarter" | "year" }`.
  - Логика: проверить, что план не free; по конфигу взять сумму и product_id; создать платёж у провайдера; сохранить запись в `payments` со статусом `pending`; вернуть клиенту `{ paymentUrl: "..." }` или `{ confirmationUrl }` (зависит от провайдера).

- **GET /api/payments** (опционально):
  - Список своих платежей (история) для личного кабинета.

- **Webhook POST /api/webhooks/payments/<provider>**:
  - Без авторизации по JWT; проверка подписи запроса (секрет провайдера).
  - При событии «успешная оплата»: найти платёж по `external_id`, если уже обработан — ничего не делать; иначе обновить пользователя (`plan_slug`, `plan_expires_at`), обновить запись в `payments` (status = succeeded, period_end и т.д.).
  - Ответить провайдеру 200 OK, чтобы он не повторял запрос.

### 4.4 Безопасность

- Webhook: проверять подпись (HMAC или как указано в доке провайдера); игнорировать запросы с неверной подписью (логировать и 401/400).
- Идемпотентность: по `external_id` не применять начисление тарифа дважды.
- Не возвращать в API внутренние id платёжной системы, если не нужно; маскировать чувствительные данные в логах.

---

## 5. Доработки фронта

- **BillingModal:**
  - Показать планы с ценами и периодами (месяц/квартал/год), если включена оплата (например, флаг из конфига или отдельный эндпоинт «доступна ли оплата»).
  - Кнопки «Оплатить» по каждому плану/периоду → вызов `POST /api/payments/create` → редирект на `paymentUrl`.
  - Сообщение «После успешной оплаты тариф обновится автоматически; при проблемах обратитесь в поддержку».
- **После возврата с платёжной страницы:** можно показать страницу «Оплата прошла» с кнопкой «Обновить тариф» (перезапросить `GET /api/plan` и контекст пользователя) или автоматически обновлять план при загрузке дашборда.
- Опционально: раздел «История платежей» (список из `GET /api/payments`).

---

## 6. Дополнительные улучшения (не только оплата)

- **Уведомления об истечении тарифа:** за N дней до `plan_expires_at` отправлять email/Telegram (напоминание продлить). Требует: фоновый джоб или проверка при входе; шаблон письма/сообщения.
- **Мягкое ограничение при истечении:** не обнулять сразу каналы/ключевые слова; дать grace period (например 3 дня «только просмотр») и затем перевести в free — опционально.
- **Цены и скидки:** хранить в БД или конфиге цены по планам и периодам; при введении промокодов — отдельная таблица `promo_codes` и проверка при создании платежа.
- **Админка:** просмотр списка платежей (все пользователи), ручное продление/назначение тарифа по-прежнему доступно.

---

## 7. Этапы реализации (чек-лист)

### Этап 1: Модель и конфиг
- [ ] Добавить модель `Payment` (или `PaymentTransaction`): user_id, external_id, provider, plan_slug, amount, currency, status, period_start, period_end, created_at, updated_at.
- [ ] Миграция БД (или ALTER в `database.py`).
- [ ] Конфиг: переменные окружения для выбранного провайдера (secret, shop id, webhook secret); маппинг plan + period → product/price (конфиг или таблица).

### Этап 2: Backend — создание платежа
- [ ] Реализовать клиент к API провайдера (создание платежа, получение ссылки).
- [ ] Эндпоинт `POST /api/payments/create`: body planSlug + period; создание платежа у провайдера; запись в `payments` (pending); возврат paymentUrl.
- [ ] Проверки: план не free; лимиты запроса (например только basic/pro/business и month/quarter/year).

### Этап 3: Backend — webhook
- [ ] Эндпоинт `POST /api/webhooks/payments/<provider>` (без JWT).
- [ ] Проверка подписи запроса; парсинг тела (id платежа, статус).
- [ ] При успехе: поиск записи в `payments` по external_id; идемпотентность (если уже succeeded — 200 без изменений); обновление user.plan_slug и user.plan_expires_at; обновление записи payment (status = succeeded).
- [ ] Логирование ошибок; ответ 200 при успешной обработке.

### Этап 4: Фронт
- [ ] В BillingModal: блок «Оплатить» с выбором плана и периода, кнопки «Оплатить» → POST /api/payments/create → redirect to paymentUrl.
- [ ] После возврата на сайт: обновление данных плана (перезапрос /api/plan и user в auth context).
- [ ] (Опционально) страница «Оплата прошла» или тост «Тариф обновлён».

### Этап 5: История и админка
- [ ] GET /api/payments — список своих платежей (дата, план, сумма, статус).
- [ ] В BillingModal или отдельная вкладка: показать последние платежи.
- [ ] Админка: список всех платежей (фильтр по user, дате), при необходимости ручное сверка с кабинетом провайдера.

### Этап 6: Дополнительно
- [ ] Напоминание об истечении тарифа (email/Telegram за N дней).
- [ ] Документация: как включить оплату, переменные окружения, настройка webhook в кабинете провайдера.
- [ ] Тесты: мок webhook, проверка идемпотентности и обновления plan_expires_at.

---

## 8. Риски и ограничения

- **Юридические:** приём платежей в РФ обычно требует ИП/ООО и договора с провайдером; ответственность за чеки и отчётность — на вас.
- **Безопасность:** утечка секретов webhook или ключей API приведёт к возможности подделки платежей; хранить в env, не логировать.
- **Повторные webhook:** провайдер может отправлять один и тот же webhook несколько раз; обязательна идемпотентность по external_id.
- **Политика продления:** при повторной оплате того же плана — продлевать от `plan_expires_at` или от текущей даты; зафиксировать в коде и в описании для пользователя.

---

## 9. Ссылки

- Текущие планы и лимиты: `plans.py`, `models.PlanLimit`, `main.py` (get_plan, _check_limits).
- Пользователь: `models.User` (plan_slug, plan_expires_at).
- Модальное окно оплаты: `components/dashboard/billing-modal.tsx`.
- ROADMAP: пункт «Тарифы и оплата» — частично реализовано (модель подписки в БД, проверка лимитов, отображение плана); остаётся интеграция с платёжным провайдером и фронт «Оплатить».

---

*Документ можно использовать как ориентир при реализации. Конкретные имена полей API и провайдера подставлять по выбранному сервису (ЮKassa, Robokassa и т.д.).*
