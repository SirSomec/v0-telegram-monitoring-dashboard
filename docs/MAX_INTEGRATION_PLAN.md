# План интеграции мессенджера MAX

Документ описывает возможность добавления парсинга сообщений из мессенджера **MAX** в сервис мониторинга (сейчас поддерживается только Telegram). Используйте этот файл как ориентир при разработке функционала.

---

## 0. Требование по развёртыванию

**Все доработки должны выполняться внутри текущих контейнеров.** Не допускается добавление новых контейнеров или отдельных сервисов для парсера MAX: новый функционал (включая MAX-сканер, миграции БД, эндпоинты API и настройки) реализуется в рамках существующего backend-контейнера и при необходимости фронтенд-контейнера. Парсер MAX запускается в том же процессе, что и Telegram-парсер (отдельный поток или таск), без выноса в отдельный образ или контейнер.

---

## 1. Резюме и целесообразность

**Вывод:** интеграция парсинга MAX технически возможна и укладывается в текущую архитектуру «мониторинг ключевых слов по чатам → сохранение упоминаний → уведомления».

- У MAX есть официальный REST API для получения сообщений и обновлений.
- Текущая модель данных (чаты, ключевые слова, упоминания) допускает расширение источником (Telegram / MAX).
- Парсер Telegram уже реализован как отдельный поток с callback; аналогичный сканер для MAX можно добавить параллельно.

**Ограничения MAX API (на момент исследования):**
- Лимит около 30 запросов в секунду на `platform-api.max.ru`.
- Для доступа нужен токен бота (создание бота в платформе MAX для партнёров).
- Получение обновлений: Webhook (HTTPS) или Long Polling.

---

## 2. Обзор MAX API

### 2.1 Основные ресурсы

| Ресурс | Назначение |
|--------|------------|
| [dev.max.ru](https://dev.max.ru/docs-api) | Документация API, OpenAPI, клиенты (Python, TypeScript, Go, Java) |
| [maxogram.ru/guide/api](https://maxogram.ru/guide/api) | Описание API и сценариев |
| `platform-api.max.ru` | Базовый хост для вызовов API |

### 2.2 Получение сообщений

**Метод:** `GET /messages`

**Параметры (основные):**
- `chat_id` — идентификатор чата (получить массив сообщений; порядок — обратный по времени).
- `message_ids` — конкретные сообщения по ID.
- `from`, `to` — фильтр по времени (Unix timestamp).
- `count` — количество сообщений в ответе (по умолчанию 50, максимум 100).

**Пример запроса:**
```http
GET https://platform-api.max.ru/messages?chat_id={chat_id}&count=100
Authorization: {access_token}
```

**Авторизация:** заголовок `Authorization` с токеном доступа (`access_token`). Токен выдаётся при создании бота в платформе MAX для партнёров.

### 2.3 Доставка обновлений

- **Webhook** — для production: нужен HTTPS-сервер, на который MAX будет отправлять события.
- **Long Polling** — периодические запросы к API (например, GET /messages с `from` = время последнего обработанного сообщения) для опроса новых сообщений по каждому отслеживаемому чату.

Для первого этапа интеграции достаточно Long Polling по списку чатов из БД с интервалом, учитывающим лимит 30 req/s.

---

## 3. Текущая архитектура сервиса (кратко)

- **Backend:** FastAPI (`main.py`), БД (SQLAlchemy, PostgreSQL).
- **Парсер:** модуль `parser.py` — класс `TelegramScanner` (Telethon), работает в отдельном потоке, подписывается на `events.NewMessage` в выбранных чатах.
- **Модели:** `User`, `Keyword`, `Chat`, `Mention`, `ChatGroup`, подписки на чаты (`user_chat_subscriptions`). Чаты идентифицируются по `tg_chat_id` или `username` (Telegram).
- **Поток данных:** новое сообщение → проверка по ключевым словам пользователей, подписанных на этот чат → запись `Mention` в БД → callback `on_mention` (WebSocket, email/Telegram уведомления).
- **Настройки парсера:** хранятся в `parser_settings` и env (см. `parser_config.py`), ключи вида `TG_*`.

---

## 4. План доработки сервиса

### 4.1 Модель данных

Цель: единая модель упоминаний и чатов с возможностью различать источник (Telegram vs MAX).

**Вариант A (рекомендуемый): колонка `source` в существующих таблицах**

- **`chats`:**
  - Добавить колонку `source`: `'telegram' | 'max'`, по умолчанию `'telegram'`.
  - Для MAX: хранить идентификатор чата MAX в отдельной колонке `max_chat_id` (или в `tg_chat_id` с соглашением, что при `source='max'` это ID чата MAX). Предпочтительно отдельная колонка `max_chat_id` (nullable), чтобы не смешивать семантику.
  - `username` для MAX можно использовать для отображаемого имени/ника чата, если API отдаёт; иначе заполнять из `title` или первого полученного имени.

- **`mentions`:**
  - Добавить колонку `source`: `'telegram' | 'max'`, по умолчанию `'telegram'`.
  - Остальные поля (`chat_id`, `message_id`, `sender_*`, `message_text`, `keyword_text`, …) остаются общими; для MAX заполнять по данным из MAX API (см. маппинг ниже).

**Маппинг полей Mention из MAX API в модель:**

| Поле модели | Источник (MAX) |
|-------------|----------------|
| `message_text` | Текст сообщения из API |
| `chat_id` | При необходимости хранить как числовой ID чата MAX (или оставить NULL и опираться на связь с Chat) |
| `chat_name` / `chat_username` | Название/идентификатор чата из ответа API |
| `message_id` | ID сообщения в MAX |
| `sender_id`, `sender_name`, `sender_username` | Данные об отправителе из API (если есть) |
| `source` | `'max'` |

**Уникальность упоминаний:** пару (user_id, chat_id, message_id, source) считать уникальной, чтобы один и тот же ответ MAX не создавал дубликатов при повторном опросе.

**Миграции БД:**
- Добавить `source` в `chats` и `mentions` (значение по умолчанию `'telegram'`).
- Добавить `max_chat_id` в `chats` (nullable, индекс при необходимости).
- При необходимости — составной уникальный индекс по `(user_id, chat_id, message_id, source)` в `mentions` (или эквивалент через уникальный constraint).

### 4.2 Настройки парсера (MAX)

Добавить ключи в `parser_config.py` и в форму настроек админки (маскировать секреты):

| Ключ | Описание |
|------|----------|
| `MAX_ACCESS_TOKEN` | Токен доступа (бот) для Authorization |
| `MAX_BASE_URL` | Базовый URL API (по умолчанию `https://platform-api.max.ru`) |
| `MAX_POLL_INTERVAL_SEC` | Интервал опроса чатов в секундах (например, 30–60) |
| `AUTO_START_MAX_SCANNER` | Запускать ли сканер MAX вместе с приложением (0/1) |

При мультипользовательском режиме список чатов и привязка к пользователям берутся из БД (чаты с `source='max'` и подписки), по аналогии с Telegram.

### 4.3 Парсер MAX (новый модуль)

- **Файл:** `parser_max.py` (или `parsers/max_scanner.py` при рефакторинге в пакет парсеров).

- **Класс:** например, `MaxScanner`:
  - Принимает `on_mention` callback с той же сигнатурой, что и Telegram (payload с полями типа `userId`, `message`, `keyword`, `messageLink`, и т.д.).
  - Конфигурация: чтение из `parser_config` (`MAX_ACCESS_TOKEN`, `MAX_BASE_URL`, интервал опроса).
  - Режимы: один пользователь (user_id) или мультипользовательский (чаты и ключевые слова из БД по подпискам и планам).

- **Алгоритм (Long Polling):**
  1. Загрузить из БД список чатов с `source='max'` и `enabled=True`, с привязкой к user_id (владелец или подписки).
  2. Для каждого чата (с учётом лимита 30 req/s): GET /messages с `chat_id`, `from` = последний обработанный timestamp (хранить в памяти или в БД), `count` до 100.
  3. Обработать новые сообщения: извлечь текст, сопоставить с ключевыми словами пользователей, имеющих доступ к этому чату; для совпадений создавать `Mention` с `source='max'` и вызывать `on_mention`.
  4. Сохранять последний обработанный timestamp/ID по чату для следующего опроса.
  5. Цикл с паузой `MAX_POLL_INTERVAL_SEC` между проходами по чатам.

- **Формат ссылки на сообщение MAX:** если в документации MAX есть формат ссылки на сообщение в веб-клиенте — формировать `messageLink` в payload; иначе передавать `null` или URL вида `{MAX_BASE_URL}/...` по документации.

- **Обработка ошибок:** логирование в `parser_log`; при 401/403 — остановка или уведомление в лог; при 429 — увеличение паузы (rate limit).

### 4.4 Интеграция в main.py и запуск

- Импорт и экземпляр: при необходимости запуска MAX-парсера создавать `MaxScanner(on_mention=_on_mention_callback)` и запускать в отдельном потоке (аналогично `TelegramScanner`).
- Единый callback `_on_mention_callback` уже передаёт payload во WebSocket и в уведомления; достаточно, чтобы payload содержал те же поля (включая при необходимости `source: 'max'` для отображения на фронте).
- Админка: в статусе парсера отображать два блока — «Telegram» (running/stopped) и «MAX» (running/stopped); кнопки «Старт/Стоп» для каждого (или общие с учётом настроек).
- Логи: общие или отдельный буфер для MAX (например, префикс `[MAX]` в тех же строках лога).

### 4.5 API и фронт

- **Добавление чата:** при создании чата (или подписке) указывать источник: Telegram или MAX. Для MAX идентификатор — `max_chat_id` (число или строка из API). В `ChatCreate` добавить поле `source?: 'telegram' | 'max'` и при MAX — поле для ID чата MAX.
- **Список чатов:** в ответе отдавать `source`; на фронте отображать иконку/метку «Telegram» или «MAX».
- **Список упоминаний:** фильтр по `source` (all / telegram / max); в карточке упоминания показывать источник и корректную ссылку на сообщение (`messageLink`).
- **Экспорт CSV:** добавить колонку `source` в выгрузку.
- **Группы каналов:** группы могут содержать и Telegram-, и MAX-чаты; лимиты считаются по общему числу каналов (или отдельно по источникам — решить в настройках тарифов при необходимости).

### 4.6 Лимиты тарифов

- На первом этапе можно считать лимит «каналов» общим для Telegram и MAX (один канал = один чат независимо от source).
- При необходимости позже ввести отдельные лимиты `max_channels` в `plan_limits` и проверять их в `_check_limits` и при добавлении MAX-чатов.

---

## 5. Этапы реализации (чек-лист)

Используйте этот список как ориентир при разработке. **На всех этапах соблюдать требование п. 0:** доработки только внутри текущих контейнеров, без новых образов/сервисов.

### Этап 1: Модель данных и миграции
- [ ] Добавить в модель `Chat` поля `source` (default `'telegram'`) и `max_chat_id` (nullable).
- [ ] Добавить в модель `Mention` поле `source` (default `'telegram'`).
- [ ] Написать миграцию (или в `database.py` проверки и ALTER TABLE), применить к БД.
- [ ] При необходимости добавить уникальный constraint по (user_id, chat_id, message_id, source) в `mentions`.

### Этап 2: Настройки и конфиг
- [ ] Добавить ключи MAX в `parser_config.get_all_parser_settings()` и в форму настроек парсера в админке.
- [ ] В `ParserSettingsOut` / `ParserSettingsUpdate` добавить поля для MAX (токен маскировать при отдаче).

### Этап 3: Парсер MAX
- [ ] Реализовать модуль `parser_max.py`: класс `MaxScanner`, чтение настроек, цикл Long Polling.
- [ ] Загрузка списка чатов с `source='max'` и привязка к пользователям (аналогично Telegram).
- [ ] Запрос GET /messages по каждому чату, парсинг ответа, сопоставление с ключевыми словами.
- [ ] Создание `Mention` с `source='max'` и вызов `on_mention` с payload в том же формате, что и Telegram (плюс `source: 'max'` при необходимости).
- [ ] Хранение последнего обработанного сообщения/времени по чату (в памяти или в БД).
- [ ] Обработка ошибок и лимитов (429), логирование в parser_log.

### Этап 4: Запуск и админка
- [ ] В `main.py`: при старте приложения при `AUTO_START_MAX_SCANNER` создавать и запускать `MaxScanner` в отдельном потоке.
- [ ] Эндпоинты админки: статус MAX-парсера (running/stopped), Start/Stop для MAX (при необходимости отдельно от Telegram).
- [ ] Отображение в админке логов с префиксом [MAX] или отдельная вкладка.

### Этап 5: API чатов и упоминаний
- [ ] В создание/редактирование чата: приём `source` и для MAX — `max_chat_id` (или аналог); парсинг идентификатора MAX при добавлении по ссылке (если MAX даёт ссылки на чаты).
- [ ] В ответах списка чатов и упоминаний возвращать `source`.
- [ ] Фильтр упоминаний по `source` (query-параметр в GET /api/mentions).
- [ ] Экспорт CSV: колонка `source`.

### Этап 6: Фронт
- [ ] При добавлении канала — выбор источника: Telegram или MAX; для MAX ввод ID чата или ссылки.
- [ ] В списке каналов и в карточке упоминания — отображение источника (Telegram/MAX) и корректной ссылки на сообщение.
- [ ] Фильтр упоминаний по источнику в UI.

### Этап 7: Документация и тесты
- [ ] Обновить README/документацию: требования (токен MAX), настройка MAX-парсера.
- [ ] При необходимости добавить тесты на маппинг ответа MAX API в Mention и на логику парсера (мок API).

---

## 6. Риски и ограничения

- **Изменение MAX API:** документация и лимиты могут меняться; закладывать возможность смены базового URL и версии API через настройки.
- **Rate limit 30 req/s:** при большом числе MAX-чатов нужно дросселировать запросы (очередь, паузы между чатами).
- **Формат ответа GET /messages:** точную структуру JSON необходимо взять из актуальной документации dev.max.ru; возможны отличия в полях отправителя/чата — маппинг в п. 4.1 уточнить по реальному ответу.
- **Авторизация бота:** пользователи сервиса не вводят свои аккаунты MAX; мониторинг идёт через один (или несколько) ботов администратора. Добавление «своего» чата MAX пользователем означает ввод chat_id, к которому у бота уже есть доступ.

---

## 7. Ссылки

- [MAX для разработчиков — документация API](https://dev.max.ru/docs-api)
- [MAX API — метод messages](https://dev.max.ru/docs-api/methods/GET/messages)
- [MAXogram — руководство по API](https://maxogram.ru/guide/api)
- Текущий парсер Telegram: `parser.py` (класс `TelegramScanner`)
- Настройки парсера: `parser_config.py`
- Модели: `models.py` (Chat, Mention, Keyword)

---

*Документ создан для планирования доработки сервиса. При реализации ориентируйтесь на актуальную документацию MAX API и текущую кодовую базу.*
