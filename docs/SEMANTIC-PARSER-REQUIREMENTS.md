# Требования к семантическому парсеру

Документ задаёт требования к компоненту семантического сопоставления (модуль `semantic.py`, сервис `semantic_service`), чтобы он соответствовал целям проекта TeleScope: мониторинг упоминаний в Telegram по смыслу ключевых слов в реальном времени, с мультиязычностью и надёжным fallback.

---

## 1. Цели проекта (контекст)

- **Задача:** находить в сообщениях Telegram упоминания по **смыслу** ключевого слова, а не только по точному вхождению подстроки.
- **Пользователи:** мультипользовательская система; ключевые слова и упоминания изолированы по `user_id`.
- **Языки:** минимум русский и английский в одном потоке; желательна поддержка смешанных и других языков.
- **Надёжность:** при недоступности семантики парсер не должен падать — семантические ключи временно обрабатываются как точные (подстрока).

---

## 2. Функциональные требования

| ID | Требование | Компонент |
|----|------------|-----------|
| F1 | **Эмбеддинги по смыслу.** Векторы должны отражать общую тему/смысл текста, а не только лексику (подходит модель типа paraphrase/sentence). | semantic_service, выбор модели |
| F2 | **Мультиязычность.** Одна модель должна обрабатывать тексты на RU, EN и при необходимости смешанные без отдельной языковой настройки. | semantic_service (модель) |
| F3 | **Порог сходства.** Порог косинусного сходства настраивается (0.0–1.0), хранится в `parser_settings` или env, применяется при сравнении. | semantic.py |
| F4 | **Пакетный ввод.** API принимает список текстов и возвращает список векторов той же длины (для кэша ключей и для сообщения + фрагментов). | semantic.py, semantic_service |
| F5 | **Сигнал недоступности.** При любой ошибке (сеть, модель, таймаут) возвращать `None` / пустой результат, чтобы парсер мог включить fallback на точный поиск. | semantic.py, semantic_service |
| F6 | **Один вызов на сообщение.** Эмбеддинг полного текста сообщения — один запрос; эмбеддинги ключевых слов кэшируются и не пересчитываются на каждое сообщение. | semantic.py (KeywordEmbeddingCache), parser.py |
| F7 | **Тема + фразы + слова.** Совпадение учитывается по любому из уровней: (1) общая тема сообщения (весь текст), (2) фрагменты сообщения (чанки по предложениям/окнам слов) — перефразирование, (3) отдельные слова — синонимы, другой язык. Если максимум из этих сходств ≥ порог — считаем совпадением. Один батч `embed([текст, чанки…, слова…])`. | parser.py (использует semantic) |

---

## 3. Конфигурация и интеграция

| ID | Требование | Компонент |
|----|------------|-----------|
| C1 | **Провайдер.** Режимы: `http` (отдельный сервис), `local` (модель в процессе бэкенда), пусто/`none` — семантика отключена. | semantic.py, parser_config / env |
| C2 | **Приоритет настроек.** Значения берутся из БД (`parser_settings`), при отсутствии — из env. | semantic.py |
| C3 | **Валидация порога.** `SEMANTIC_SIMILARITY_THRESHOLD` только в диапазоне [0, 1]; иначе подставлять значение по умолчанию (например 0.55). | semantic.py |
| C4 | **URL сервиса.** При `SEMANTIC_PROVIDER=http` обязателен `SEMANTIC_SERVICE_URL`; бэкенд обращается к `/embed` и `/health` (база URL без суффикса). | semantic.py, semantic_service |

---

## 4. Надёжность и граничные случаи

| ID | Требование | Компонент |
|----|------------|-----------|
| R1 | **Таймауты.** HTTP: ограниченное время ожидания (например 5 с для health, 30 с для embed), чтобы парсер не зависал. | semantic.py |
| R2 | **Пустой ввод.** Пустой список текстов или пустые строки в списке не вызывают ошибку; возвращается пустой список векторов или пропуск пустых. | semantic.py, semantic_service |
| R3 | **Fallback при недоступности.** Если `embed()` вернул `None`, парсер использует для семантических ключей только проверку подстроки. | parser.py (уже так) |
| R4 | **Консистентность модели.** Ключи и сообщения (и чанки) эмбедятся одной и той же моделью/сервисом, чтобы косинусное сходство было осмысленным. | semantic.py, semantic_service |

---

## 5. Производительность и масштаб

| ID | Требование | Компонент |
|----|------------|-----------|
| P1 | **Кэш ключей.** Эмбеддинги семантических ключевых слов кэшируются; обновление только при появлении новых ключей в наборе. | semantic.py (KeywordEmbeddingCache) |
| P2 | **Размер батча.** Сервис должен устойчиво обрабатывать запросы с десятками текстов (ключи + сообщение + до ~6 чанков). | semantic_service |
| P3 | **Длина текста.** Модели имеют лимит токенов; слишком длинные тексты должны обрезаться или обрабатываться по контракту (например макс. 512 токенов), без падения сервиса. | semantic_service (рекомендуется доработка) |

---

## 6. Контракт API сервиса (HTTP)

| Эндпоинт | Метод | Назначение |
|----------|--------|------------|
| `/health` | GET | Проверка доступности; бэкенд использует для `is_semantic_available()`. |
| `/embed` | POST | Тело: `{"texts": ["...", ...]}`. Ответ: `{"vectors": [[...], ...]}` — один вектор на каждый элемент `texts` (порядок сохранён). |

- При ошибке сервис может вернуть 5xx; бэкенд трактует это как недоступность и возвращает `None` из `embed()`.

---

## 7. Требования с точки зрения пользовательского опыта (UX)

Ожидания пользователя дашборда (не админа): он добавляет ключевые слова, выбирает режим «Точное» или «ИИ семантика», смотрит ленту упоминаний и хочет понимать, почему сообщение попало в выборку. Админ настраивает парсер и порог — ему нужна ясность без погружения в косинусное сходство.

### 7.1. Понятность выбора режима (ключевые слова)

| ID | Требование | Где |
|----|------------|-----|
| UX1 | **Понятная формулировка.** Пользователь должен без документации понимать разницу: «Точное» — слово/фраза есть в тексте буквально; «ИИ семантика» — сообщение по смыслу совпадает с темой ключа (синонимы, перефразирование, другой язык). | Дашборд: форма добавления ключевого слова |
| UX2 | **Визуальное различие.** В списке ключевых слов явно видно, у какого ключа режим «точное», у какого «семантика» (иконка, бейдж), чтобы не гадать при просмотре ленты. | Дашборд: список ключевых слов |
| UX3 | **Режим по умолчанию для новых ключей.** Переключатель «Точное» / «ИИ семантика» задаёт режим только для *следующего* добавляемого ключа; уже созданные ключи не меняются. Поведение должно быть предсказуемым. | Дашборд: KeywordsManager |

### 7.2. Прозрачность в ленте упоминаний

| ID | Требование | Где |
|----|------------|-----|
| UX4 | **Почему сообщение попало.** Для семантического совпадения пользователь видит степень совпадения с темой (например «Совпадение с темой: 72%»), чтобы не было ощущения «притянуто за уши». Для точного совпадения достаточно подсветки ключа в тексте. | Лента: карточка упоминания |
| UX5 | **Единый вид упоминаний.** Упоминания от точного и семантического поиска не разделяются по разным лентам/вкладкам — одна лента, один формат; различие только в наличии процента и типа ключа (иконка/бейдж ключа при желании). | Лента, API |
| UX6 | **Подсветка в тексте.** Если ключ встретился по смыслу, в тексте может не быть буквального вхождения; подсветка тогда либо не показывается, либо показывается фрагмент, наиболее близкий по смыслу (если реализовано). Ожидание: пользователь не в шоке от отсутствия подсветки при семантическом совпадении. | Лента: highlightKeywords, подсказки |

### 7.3. Предсказуемость и доверие

| ID | Требование | Где |
|----|------------|-----|
| UX7 | **Стабильность поведения.** При одинаковом пороге и тех же ключах сообщения с похожим смыслом должны стабильно попадать в ленту; не «иногда да, иногда нет» без смены настроек. | Бэкенд: фиксированный порог, одна модель |
| UX8 | **Fallback без сюрпризов.** Если семантика недоступна и ключи временно обрабатываются как точные, пользователь не обязан это знать; важно, чтобы парсер не падал и упоминания не пропадали. При желании в админке можно показывать статус «Семантика: доступна / недоступна». | Парсер, админка (опционально) |
| UX9 | **Лимиты по тарифу.** Если введены лимиты на число семантических ключей, при достижении лимита пользователь видит понятное сообщение («Достигнут лимит семантических ключей по вашему тарифу») и не может добавить семантический ключ, пока не перейдёт на другой тариф или не удалит существующий. | Дашборд: форма добавления ключа, раздел «Оплата» |

### 7.4. Админка: настройки парсера и семантики

| ID | Требование | Где |
|----|------------|-----|
| UX10 | **Человекочитаемые подсказки.** Поля «Порог сходства», «URL сервиса», «Провайдер» сопровождаются краткими подсказками: что меняется при увеличении/уменьшении порога, какой URL указать в Docker, что будет при отключении семантики. | Админка: Парсер → настройки семантики |
| UX11 | **Порог без формул.** Описание порога — в терминах результата: «ниже — больше срабатываний, выше — строже совпадение», без обязательного упоминания «косинусное сходство» в основном интерфейсе. | Админка: подсказка к SEMANTIC_SIMILARITY_THRESHOLD |
| UX12 | **Состояние сервиса.** Админ при необходимости может понять, доступен ли сервис эмбеддингов (например индикатор «Семантика: работает» рядом с настройками или в статусе парсера), чтобы не искать причину в логах. | Админка: Парсер (опционально) |

### 7.5. Производительность и отзывчивость

| ID | Требование | Где |
|----|------------|-----|
| UX13 | **Парсер не «висит».** Обработка сообщений не блокируется надолго из‑за запроса к сервису эмбеддингов; таймауты ограничены, при недоступности — быстрый fallback. Пользователь не замечает задержек в ленте из‑за семантики. | semantic.py, parser |
| UX14 | **Первый запрос.** По возможности первый запрос к семантике после старта не создаёт многократную задержку (прогрев модели в контейнере или быстрый health). | semantic_service, деплой |

---

Итог: с точки зрения UX семантический парсер должен быть **понятным** (режим ключа и процент в ленте), **предсказуемым** (одинаковый порог → стабильный результат), **прозрачным** (видно, почему сообщение попало), **без сюрпризов** при недоступности сервиса и **отзывчивым** по времени ответа.

---

## 8. Рекомендуемые доработки (для соответствия целям)

| ID | Доработка | Зачем |
|----|-----------|--------|
| D1 | **Лимит длины текста в сервисе.** Обрезать или отклонять слишком длинные строки (например > 8192 символов или макс. N токенов под модель), чтобы избежать таймаутов и OOM. | Стабильность, предсказуемость |
| D2 | **Опциональный прогрев модели.** Переменная `SEMANTIC_PRELOAD=1` в контейнере — загрузить модель при старте, чтобы первый запрос не задерживался. | UX первого сообщения |
| D3 | **Размер батча в контракте.** В документации или в коде зафиксировать рекомендуемый максимум текстов в одном запросе (например 50–100). | Защита от злоупотреблений и OOM |
| D4 | **Единый порог в документации.** В REQUIREMENTS.md и .env.example указать одно значение по умолчанию (например 0.55 для баланса охвата/точности). | Согласованность с кодом (semantic.py уже 0.55) |

---

## 9. Связь с существующими требованиями

- **REQUIREMENTS.md, раздел 3.2.1 (SP1–SP8):** перечисленные там пункты остаются в силе; данный документ уточняет технические требования к *реализации* семантического парсера (модуль + сервис), чтобы они этим целям соответствовали.
- **Тарифы (SP6):** ограничение числа семантических ключей по тарифу делается в бэкенде/лимитах, не в самом парсере эмбеддингов.

---

Документ можно дополнять по мере появления новых требований (например метрики, логирование, A/B порога).
