# Пароль PostgreSQL: задайте в .env как POSTGRES_PASSWORD или оставьте postgres.
# Важно: если том postgres_data уже создан с другим паролем, либо задайте тот же пароль в .env,
# либо удалите том (docker compose down -v) и поднимите заново — данные БД будут потеряны.
services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: telegram_monitor
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  semantic:
    build:
      context: ./semantic_service
      dockerfile: Dockerfile
    environment:
      SEMANTIC_MODEL_NAME: ${SEMANTIC_MODEL_NAME:-sentence-transformers/paraphrase-multilingual-mpnet-base-v2}
    env_file:
      - .env
    # Порт наружу не пробрасываем, доступ только из backend
    expose:
      - "8001"

  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    environment:
      DATABASE_URL: postgresql+psycopg2://postgres:${POSTGRES_PASSWORD:-postgres}@postgres:5432/telegram_monitor
      JWT_SECRET: ${JWT_SECRET:-change-me-in-production}
      TG_API_ID: ${TG_API_ID}
      TG_API_HASH: ${TG_API_HASH}
      TG_SESSION_STRING: ${TG_SESSION_STRING:-}
      TG_SESSION_NAME: ${TG_SESSION_NAME:-telegram_monitor}
      AUTO_START_SCANNER: ${AUTO_START_SCANNER:-0}
      MULTI_USER_SCANNER: ${MULTI_USER_SCANNER:-1}
      TG_USER_ID: ${TG_USER_ID:-1}
      # Пусто — бэкенд разрешает любой origin (https?://.*). Для прода при необходимости задайте в .env: CORS_ORIGINS=https://ваш-домен.com
      CORS_ORIGINS: ${CORS_ORIGINS:-}
      SEMANTIC_PROVIDER: ${SEMANTIC_PROVIDER:-http}
      SEMANTIC_SERVICE_URL: ${SEMANTIC_SERVICE_URL:-http://semantic:8001}
      SEMANTIC_SIMILARITY_THRESHOLD: ${SEMANTIC_SIMILARITY_THRESHOLD:-0.55}
    env_file:
      - .env
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      semantic:
        condition: service_started

  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend
      args:
        NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-}
        API_PROXY_TARGET: http://backend:8000
    environment:
      API_PROXY_TARGET: http://backend:8000
    ports:
      - "3000:3000"
    depends_on:
      - backend

  # Nginx — единая точка входа по портам 80 и 443 (для доступа по домену integration-wa.ru).
  # HTTPS: после certbot на хосте смонтируйте /etc/letsencrypt (см. комментарий к volumes).
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./deploy/nginx-integration-wa.ru-docker.conf:/etc/nginx/conf.d/default.conf:ro
      # Сертификаты Let's Encrypt с хоста (после: sudo certbot certonly --standalone -d integration-wa.ru)
      - /etc/letsencrypt:/etc/letsencrypt:ro
    depends_on:
      - frontend
      - backend

volumes:
  postgres_data:
