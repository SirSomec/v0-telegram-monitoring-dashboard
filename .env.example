# --- Database ---
# Для локального запуска (без Docker):
# postgresql+psycopg2://postgres:postgres@localhost:5432/telegram_monitor
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/telegram_monitor

# Для Docker Compose: пароль PostgreSQL. Подставляется в контейнер postgres и в DATABASE_URL бэкенда.
# При первом запуске задайте любой (например postgres). Если том уже создан с другим паролем — укажите тот же здесь
# или пересоздайте том: docker compose down -v && docker compose up -d (данные БД удалятся).
# POSTGRES_PASSWORD=postgres

# --- Auth (JWT) ---
# Обязательно смените в проде
JWT_SECRET=change-me-in-production

# --- Восстановление пароля (email) ---
# Базовый URL фронта для ссылок в письмах (например https://app.example.com)
# FRONTEND_URL=https://app.example.com
# SMTP (для отправки писем со ссылкой сброса пароля):
# SMTP_HOST=smtp.example.com
# SMTP_PORT=587
# SMTP_USER=
# SMTP_PASSWORD=
# SMTP_FROM=noreply@example.com
# SMTP_USE_TLS=1

# --- Уведомления в Telegram (бот для отправки пользователям) ---
# NOTIFY_TELEGRAM_BOT_TOKEN=123:ABC...

# --- FastAPI / Scanner ---
# Автозапуск TelegramScanner вместе с uvicorn
AUTO_START_SCANNER=0
# 1 = мониторинг для всех пользователей (чаты/ключевые слова из БД). 0 = один пользователь (TG_USER_ID)
MULTI_USER_SCANNER=1
TG_USER_ID=1

# --- Telegram (Telethon) ---
TG_API_ID=123456
TG_API_HASH=your_api_hash_here

# Рекомендуется для server-mode (без интерактивного логина):
# 1) локально создайте StringSession (Telethon) и вставьте сюда
TG_SESSION_STRING=

# Альтернатива: session файл по имени (будет создан рядом с запуском)
TG_SESSION_NAME=telegram_monitor

# (Опционально) Если используете Bot API
TG_BOT_TOKEN=

# Чаты для мониторинга (через запятую): @username, username или числовые id (-100...)
# Если пусто — берутся enabled-чаты из таблицы chats, а если там тоже пусто — слушаем все доступные чаты.
TG_CHATS=

# --- SOCKS5 proxy (актуально для РФ) ---
TG_PROXY_HOST=
TG_PROXY_PORT=
TG_PROXY_USER=
TG_PROXY_PASS=

# --- Семантический поиск (ИИ) ---
# http = отдельный контейнер semantic (рекомендуется в проде). local = модель в процессе бэкенда. Пусто/none = только точный поиск.
# При недоступности семантики ключи с режимом «семантика» временно считаются как точные (подстрока).
# SEMANTIC_PROVIDER=http
# URL сервиса эмбеддингов (при SEMANTIC_PROVIDER=http). В Docker Compose по умолчанию: http://semantic:8001
# SEMANTIC_SERVICE_URL=http://semantic:8001
# Модель для эмбеддингов (в контейнере semantic или при SEMANTIC_PROVIDER=local)
# SEMANTIC_MODEL_NAME=sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2
# Порог косинусного сходства 0.0–1.0 (по умолчанию 0.7). Выше = строже совпадение.
# SEMANTIC_SIMILARITY_THRESHOLD=0.7

# --- CORS (для прода) ---
# Разрешённые origins через запятую. По умолчанию — localhost.
# CORS_ORIGINS=https://app.example.com,https://www.example.com

# --- Frontend (Next.js) ---
# URL бэкенда для запросов из браузера. Подставляется при сборке образа фронта.
# Пусто: запросы идут на тот же хост (/auth, /api), Next.js проксирует на бэкенд — подходит при одном порте или Nginx.
# Деплой по IP (фронт :3000, бэкенд :8000): задайте, например NEXT_PUBLIC_API_URL=http://IP:8000 (порт 8000 должен быть доступен).
# После изменения пересоберите фронт: docker compose build --no-cache frontend && docker compose up -d
# NEXT_PUBLIC_API_URL=
