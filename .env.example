# --- Database ---
# Для локального запуска (без Docker):
# postgresql+psycopg2://postgres:postgres@localhost:5432/telegram_monitor
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/telegram_monitor

# Для Docker Compose: пароль PostgreSQL. Подставляется в контейнер postgres и в DATABASE_URL бэкенда.
# При первом запуске задайте любой (например postgres). Если том уже создан с другим паролем — укажите тот же здесь
# или пересоздайте том: docker compose down -v && docker compose up -d (данные БД удалятся).
# POSTGRES_PASSWORD=postgres

# --- Auth (JWT) ---
# Обязательно смените в проде
JWT_SECRET=change-me-in-production

# --- Восстановление пароля (email) ---
# Базовый URL фронта для ссылок в письмах (например https://app.example.com)
# FRONTEND_URL=https://app.example.com
# SMTP (для отправки писем со ссылкой сброса пароля):
# SMTP_HOST=smtp.example.com
# SMTP_PORT=587
# SMTP_USER=
# SMTP_PASSWORD=
# SMTP_FROM=noreply@example.com
# SMTP_USE_TLS=1

# --- Уведомления в Telegram (бот @telescopemsg_bot для отправки пользователям и приёма /start) ---
# Токен бота: получить у @BotFather, указать в настройках webhook URL (см. README).
# NOTIFY_TELEGRAM_BOT_TOKEN=123:ABC...

# --- FastAPI / Scanner ---
# Автозапуск TelegramScanner вместе с uvicorn
AUTO_START_SCANNER=0
# 1 = мониторинг для всех пользователей (чаты/ключевые слова из БД). 0 = один пользователь (TG_USER_ID)
MULTI_USER_SCANNER=1
TG_USER_ID=1

# --- Telegram (Telethon) ---
TG_API_ID=123456
TG_API_HASH=your_api_hash_here

# Рекомендуется для server-mode (без интерактивного логина):
# 1) локально создайте StringSession (Telethon) и вставьте сюда
TG_SESSION_STRING=

# Альтернатива: session файл по имени (будет создан рядом с запуском)
TG_SESSION_NAME=telegram_monitor

# (Опционально) Если используете Bot API
TG_BOT_TOKEN=

# Чаты для мониторинга (через запятую): @username, username или числовые id (-100...)
# Если пусто — берутся enabled-чаты из таблицы chats, а если там тоже пусто — слушаем все доступные чаты.
TG_CHATS=

# --- SOCKS5 proxy (актуально для РФ) ---
TG_PROXY_HOST=
TG_PROXY_PORT=
TG_PROXY_USER=
TG_PROXY_PASS=

# --- Семантический поиск (ИИ) ---
# Настройки можно задать в админке (Настройки парсера → Семантический анализ). Здесь — значения по умолчанию.
# http = отдельный контейнер semantic (рекомендуется). local = модель в процессе бэкенда. Пусто = только точный поиск.
# SEMANTIC_PROVIDER=http
# SEMANTIC_SERVICE_URL=http://semantic:8001
# Модель: понимание общей темы сообщения, английский и русский (paraphrase-multilingual-mpnet-base-v2).
# SEMANTIC_MODEL_NAME=sentence-transformers/paraphrase-multilingual-mpnet-base-v2
# Порог сходства 0.0–1.0. 0.55 — баланс охвата темы; ниже — больше срабатываний, выше — строже.
# SEMANTIC_SIMILARITY_THRESHOLD=0.55

# --- CORS (доступ по домену) ---
# Пусто или не задано — бэкенд разрешает любой origin (работают и IP, и домен).
# Если доступ по домену не работает: удалите или закомментируйте CORS_ORIGINS в .env (старое значение ограничивало только localhost).
# Для ограничения в прода задайте: CORS_ORIGINS=https://ваш-домен.com
# CORS_ORIGINS=

# --- Frontend (Next.js) ---
# URL бэкенда для запросов из браузера. Подставляется при сборке образа фронта.
# Пусто: запросы идут на тот же хост (/auth, /api), Next.js проксирует на бэкенд — подходит при одном порте или Nginx.
# Деплой по IP (фронт :3000, бэкенд :8000): задайте, например NEXT_PUBLIC_API_URL=http://IP:8000 (порт 8000 должен быть доступен).
# После изменения пересоберите фронт: docker compose build --no-cache frontend && docker compose up -d
# NEXT_PUBLIC_API_URL=
